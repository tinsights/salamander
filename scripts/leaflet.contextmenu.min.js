/*
	Leaflet.contextmenu, a context menu for Leaflet.
	(c) 2015, Adam Ratcliffe, GeoSmart Maps Limited

	@preserve
*/
(function (t) { let e; if (typeof define === 'function' && define.amd) { define(['leaflet'], t); } else if (typeof module === 'object' && typeof module.exports === 'object') { e = require('leaflet'); module.exports = t(e); } else { if (typeof window.L === 'undefined') { throw new Error('Leaflet must be loaded first'); }t(window.L); } }((t) => {
  t.Map.mergeOptions({ contextmenuItems: [] }); t.Map.ContextMenu = t.Handler.extend({
    _touchstart: t.Browser.msPointer ? 'MSPointerDown' : t.Browser.pointer ? 'pointerdown' : 'touchstart',
    statics: { BASE_CLS: 'leaflet-contextmenu' },
    initialize(e) { t.Handler.prototype.initialize.call(this, e); this._items = []; this._visible = false; const n = this._container = t.DomUtil.create('div', t.Map.ContextMenu.BASE_CLS, e._container); n.style.zIndex = 1e4; n.style.position = 'absolute'; if (e.options.contextmenuWidth) { n.style.width = `${e.options.contextmenuWidth}px`; } this._createItems(); t.DomEvent.on(n, 'click', t.DomEvent.stop).on(n, 'mousedown', t.DomEvent.stop).on(n, 'dblclick', t.DomEvent.stop).on(n, 'contextmenu', t.DomEvent.stop); },
    addHooks() { const e = this._map.getContainer(); t.DomEvent.on(e, 'mouseleave', this._hide, this).on(document, 'keydown', this._onKeyDown, this); if (t.Browser.touch) { t.DomEvent.on(document, this._touchstart, this._hide, this); } this._map.on({ contextmenu: this._show, mousedown: this._hide, zoomstart: this._hide }, this); },
    removeHooks() { const e = this._map.getContainer(); t.DomEvent.off(e, 'mouseleave', this._hide, this).off(document, 'keydown', this._onKeyDown, this); if (t.Browser.touch) { t.DomEvent.off(document, this._touchstart, this._hide, this); } this._map.off({ contextmenu: this._show, mousedown: this._hide, zoomstart: this._hide }, this); },
    showAt(e, n) { if (e instanceof t.LatLng) { e = this._map.latLngToContainerPoint(e); } this._showAtPoint(e, n); },
    hide() { this._hide(); },
    addItem(t) { return this.insertItem(t); },
    insertItem(t, e) { e = e !== undefined ? e : this._items.length; const n = this._createItem(this._container, t, e); this._items.push(n); this._sizeChanged = true; this._map.fire('contextmenu.additem', { contextmenu: this, el: n.el, index: e }); return n.el; },
    removeItem(e) { const n = this._container; if (!isNaN(e)) { e = n.children[e]; } if (e) { this._removeItem(t.Util.stamp(e)); this._sizeChanged = true; this._map.fire('contextmenu.removeitem', { contextmenu: this, el: e }); return e; } return null; },
    removeAllItems() { const e = this._container.children; let n; while (e.length) { n = e[0]; this._removeItem(t.Util.stamp(n)); } return e; },
    hideAllItems() { let t; let e; let n; for (e = 0, n = this._items.length; e < n; e++) { t = this._items[e]; t.el.style.display = 'none'; } },
    showAllItems() { let t; let e; let n; for (e = 0, n = this._items.length; e < n; e++) { t = this._items[e]; t.el.style.display = ''; } },
    setDisabled(e, n) { const i = this._container; const o = `${t.Map.ContextMenu.BASE_CLS}-item`; if (!isNaN(e)) { e = i.children[e]; } if (e && t.DomUtil.hasClass(e, o)) { if (n) { t.DomUtil.addClass(e, `${o}-disabled`); this._map.fire('contextmenu.disableitem', { contextmenu: this, el: e }); } else { t.DomUtil.removeClass(e, `${o}-disabled`); this._map.fire('contextmenu.enableitem', { contextmenu: this, el: e }); } } },
    isVisible() { return this._visible; },
    _createItems() { const t = this._map.options.contextmenuItems; let e; let n; let i; for (n = 0, i = t.length; n < i; n++) { this._items.push(this._createItem(this._container, t[n])); } },
    _createItem(e, n, i) { if (n.separator || n === '-') { return this._createSeparator(e, i); } const o = `${t.Map.ContextMenu.BASE_CLS}-item`; const s = n.disabled ? `${o} ${o}-disabled` : o; const h = this._insertElementAt('a', s, e, i); const r = this._createEventHandler(h, n.callback, n.context, n.hideOnSelect); const a = this._getIcon(n); const m = this._getIconCls(n); let u = ''; if (a) { u = `<img class="${t.Map.ContextMenu.BASE_CLS}-icon" src="${a}"/>`; } else if (m) { u = `<span class="${t.Map.ContextMenu.BASE_CLS}-icon ${m}"></span>`; }h.innerHTML = u + n.text; h.href = '#'; t.DomEvent.on(h, 'mouseover', this._onItemMouseOver, this).on(h, 'mouseout', this._onItemMouseOut, this).on(h, 'mousedown', t.DomEvent.stopPropagation).on(h, 'click', r); if (t.Browser.touch) { t.DomEvent.on(h, this._touchstart, t.DomEvent.stopPropagation); } if (!t.Browser.pointer) { t.DomEvent.on(h, 'click', this._onItemMouseOut, this); } return { id: t.Util.stamp(h), el: h, callback: r }; },
    _removeItem(e) { let n; let i; let o; let s; let h; for (o = 0, s = this._items.length; o < s; o++) { n = this._items[o]; if (n.id === e) { i = n.el; h = n.callback; if (h) { t.DomEvent.off(i, 'mouseover', this._onItemMouseOver, this).off(i, 'mouseover', this._onItemMouseOut, this).off(i, 'mousedown', t.DomEvent.stopPropagation).off(i, 'click', h); if (t.Browser.touch) { t.DomEvent.off(i, this._touchstart, t.DomEvent.stopPropagation); } if (!t.Browser.pointer) { t.DomEvent.on(i, 'click', this._onItemMouseOut, this); } } this._container.removeChild(i); this._items.splice(o, 1); return n; } } return null; },
    _createSeparator(e, n) { const i = this._insertElementAt('div', `${t.Map.ContextMenu.BASE_CLS}-separator`, e, n); return { id: t.Util.stamp(i), el: i }; },
    _createEventHandler(e, n, i, o) {
      const s = this; const h = this._map; const r = `${t.Map.ContextMenu.BASE_CLS}-item-disabled`; var o = o !== undefined ? o : true; return function (h) {
        if (t.DomUtil.hasClass(e, r)) { return; } const a = s._map; const m = s._showLocation.containerPoint; const u = a.containerPointToLayerPoint(m); const l = a.layerPointToLatLng(u); const c = s._showLocation.relatedTarget; const f = {
          containerPoint: m, layerPoint: u, latlng: l, relatedTarget: c,
        }; if (o) { s._hide(); } if (n) { n.call(i || a, f); }s._map.fire('contextmenu.select', { contextmenu: s, el: e });
      };
    },
    _insertElementAt(t, e, n, i) { let o; const s = document.createElement(t); s.className = e; if (i !== undefined) { o = n.children[i]; } if (o) { n.insertBefore(s, o); } else { n.appendChild(s); } return s; },
    _show(t) { this._showAtPoint(t.containerPoint, t); },
    _showAtPoint(e, n) { if (this._items.length) { const i = this._map; const o = t.extend(n || {}, { contextmenu: this }); this._showLocation = { containerPoint: e }; if (n && n.relatedTarget) { this._showLocation.relatedTarget = n.relatedTarget; } this._setPosition(e); if (!this._visible) { this._container.style.display = 'block'; this._visible = true; } this._map.fire('contextmenu.show', o); } },
    _hide() { if (this._visible) { this._visible = false; this._container.style.display = 'none'; this._map.fire('contextmenu.hide', { contextmenu: this }); } },
    _getIcon(e) { return t.Browser.retina && e.retinaIcon || e.icon; },
    _getIconCls(e) { return t.Browser.retina && e.retinaIconCls || e.iconCls; },
    _setPosition(e) { const n = this._map.getSize(); const i = this._container; const o = this._getElementSize(i); let s; if (this._map.options.contextmenuAnchor) { s = t.point(this._map.options.contextmenuAnchor); e = e.add(s); }i._leaflet_pos = e; if (e.x + o.x > n.x) { i.style.left = 'auto'; i.style.right = `${Math.min(Math.max(n.x - e.x, 0), n.x - o.x - 1)}px`; } else { i.style.left = `${Math.max(e.x, 0)}px`; i.style.right = 'auto'; } if (e.y + o.y > n.y) { i.style.top = 'auto'; i.style.bottom = `${Math.min(Math.max(n.y - e.y, 0), n.y - o.y - 1)}px`; } else { i.style.top = `${Math.max(e.y, 0)}px`; i.style.bottom = 'auto'; } },
    _getElementSize(t) { let e = this._size; const n = t.style.display; if (!e || this._sizeChanged) { e = {}; t.style.left = '-999999px'; t.style.right = 'auto'; t.style.display = 'block'; e.x = t.offsetWidth; e.y = t.offsetHeight; t.style.left = 'auto'; t.style.display = n; this._sizeChanged = false; } return e; },
    _onKeyDown(t) { const e = t.keyCode; if (e === 27) { this._hide(); } },
    _onItemMouseOver(e) { t.DomUtil.addClass(e.target || e.srcElement, 'over'); },
    _onItemMouseOut(e) { t.DomUtil.removeClass(e.target || e.srcElement, 'over'); },
  }); t.Map.addInitHook('addHandler', 'contextmenu', t.Map.ContextMenu); t.Mixin.ContextMenu = {
    bindContextMenu(e) { t.setOptions(this, e); this._initContextMenu(); return this; }, unbindContextMenu() { this.off('contextmenu', this._showContextMenu, this); return this; }, addContextMenuItem(t) { this.options.contextmenuItems.push(t); }, removeContextMenuItemWithIndex(t) { const e = []; for (let n = 0; n < this.options.contextmenuItems.length; n++) { if (this.options.contextmenuItems[n].index == t) { e.push(n); } } let i = e.pop(); while (i !== undefined) { this.options.contextmenuItems.splice(i, 1); i = e.pop(); } }, replaceContextMenuItem(t) { this.removeContextMenuItemWithIndex(t.index); this.addContextMenuItem(t); }, _initContextMenu() { this._items = []; this.on('contextmenu', this._showContextMenu, this); }, _showContextMenu(e) { let n; let i; let o; let s; let h; if (this._map.contextmenu) { i = t.extend({ relatedTarget: this }, e); o = this._map.mouseEventToContainerPoint(e.originalEvent); if (!this.options.contextmenuInheritItems) { this._map.contextmenu.hideAllItems(); } for (s = 0, h = this.options.contextmenuItems.length; s < h; s++) { n = this.options.contextmenuItems[s]; this._items.push(this._map.contextmenu.insertItem(n, n.index)); } this._map.once('contextmenu.hide', this._hideContextMenu, this); this._map.contextmenu.showAt(o, i); } }, _hideContextMenu() { let t; let e; for (t = 0, e = this._items.length; t < e; t++) { this._map.contextmenu.removeItem(this._items[t]); } this._items.length = 0; if (!this.options.contextmenuInheritItems) { this._map.contextmenu.showAllItems(); } },
  }; const e = [t.Marker, t.Path]; const n = { contextmenu: false, contextmenuItems: [], contextmenuInheritItems: true }; let i; let o; let s; for (o = 0, s = e.length; o < s; o++) { i = e[o]; if (!i.prototype.options) { i.prototype.options = n; } else { i.mergeOptions(n); }i.addInitHook(function () { if (this.options.contextmenu) { this._initContextMenu(); } }); i.include(t.Mixin.ContextMenu); } return t.Map.ContextMenu;
}));
